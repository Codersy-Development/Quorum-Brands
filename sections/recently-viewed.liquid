{%- liquid
  assign row_of = section.settings.recent_count
  capture gridView
    render 'products_per_row', products_per_row: row_of, style: 'fractions'
  endcapture
  # On smaller screen sizes, 39vw is used for grid items in the CSS
  capture sizes
    render 'sizes-explicit', sizeVariable: gridView, fallback: '39vw'
  endcapture
-%}
<div
  data-subsection
  data-section-id="{{ section.id }}"
  data-section-type="recently-viewed"
  data-product-handle="{{ product.handle }}"
  data-recent-count="{{ section.settings.recent_count }}"
  data-grid-item-class="{{ gridView }}"
  data-row-of="{{ row_of }}"
  data-image-sizes="{{ sizes }}"
>
  <hr class="hr--large">
  <div class="index-section index-section--small">
    <div class="page-width">
      <header class="section-header">
        <h3 class="section-header__title" id="recently-viewed-title-{{ section.id }}">{{ 'products.general.recent_products' | t }}</h3>
      </header>
    </div>
    <div class="page-width page-width--flush-small">
      <div class="grid-overflow-wrapper">
        <div id="RecentlyViewed-{{ section.id }}" class="grid grid--uniform" data-aos="overflow__animation"></div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const recentlyViewedSection = document.querySelector('[data-section-type="recently-viewed"]');
  if (!recentlyViewedSection) return;
  
  const sectionId = '{{ section.id }}';
  const recentlyViewedContainer = document.getElementById('RecentlyViewed-' + sectionId);
  const titleElement = document.getElementById('recently-viewed-title-' + sectionId);
  
  // Store original recently viewed function if it exists
  let originalGetRecentProducts = null;
  if (window.recentlyViewed && window.recentlyViewed.getRecentProducts) {
    originalGetRecentProducts = window.recentlyViewed.getRecentProducts.bind(window.recentlyViewed);
  }
  
  // Function to switch store and navigate to product
  function switchStoreAndNavigate(productUrl, productVendor) {
    console.log('Switching to store:', productVendor, 'for product:', productUrl);
    
    // Update localStorage
    localStorage.setItem('store-selected', productVendor.toLowerCase());
    
    // Update store switcher radio buttons
    const storeRadios = document.querySelectorAll('store-switcher input[type="radio"]');
    storeRadios.forEach(radio => {
      if (radio.value.toLowerCase() === productVendor.toLowerCase()) {
        radio.checked = true;
      } else {
        radio.checked = false;
      }
    });
    
    // Update HTML dataset
    const htmlEl = document.querySelector('html');
    if (htmlEl) {
      htmlEl.dataset.storeSelected = productVendor.toLowerCase();
    }
    
    // Dispatch store change event
    const storeChangedEvent = new CustomEvent('storeChanged', {
      detail: { 
        selectedStore: productVendor.toLowerCase(),
        triggeredBy: 'recently-viewed-click'
      },
      bubbles: true
    });
    document.dispatchEvent(storeChangedEvent);
    
    // Navigate to product with vendor filter
    const url = new URL(productUrl, window.location.origin);
    if (!productVendor.toLowerCase().includes('shop all')) {
      // Capitalize first letter for vendor filter
      const capitalizedVendor = productVendor.charAt(0).toUpperCase() + productVendor.slice(1);
      url.searchParams.set('filter.p.vendor', capitalizedVendor);
    }
    
    // Navigate to the product
    window.location.href = url.toString();
  }
  
  // Function to add click handlers to recently viewed products
  function addProductClickHandlers() {
    if (!recentlyViewedContainer) return;
    
    const productItems = recentlyViewedContainer.querySelectorAll(
      '.grid-product, .product-item, .grid__item, [data-product-id], [class*="product"]'
    );
    
    productItems.forEach((item) => {
      // Find the product link
      const productLink = item.querySelector('a[href*="/products/"]');
      if (!productLink) return;
      
      // Get vendor information
      let productVendor = '';
      if (item.dataset.vendor) {
        productVendor = item.dataset.vendor;
      } else {
        // Try to find vendor from text content or other sources
        const vendorElement = item.querySelector('.grid-product__vendor, [class*="vendor"]');
        if (vendorElement) {
          productVendor = vendorElement.textContent.trim();
        } else {
          // Check text content for vendor names
          const itemText = item.textContent.toLowerCase();
          if (itemText.includes('oxygen')) {
            productVendor = 'oxygen';
          } else if (itemText.includes('quorum')) {
            productVendor = 'quorum';
          }
        }
      }
      
      // Add vendor as data attribute if not already present
      if (productVendor && !item.dataset.vendor) {
        item.dataset.vendor = productVendor.toLowerCase();
      }
      
      // Add click handler
      productLink.addEventListener('click', function(e) {
        if (!productVendor) {
          // No vendor detected, proceed normally
          return;
        }
        
        const currentStore = localStorage.getItem('store-selected') || '';
        const targetVendor = productVendor.toLowerCase();
        
        console.log('Recently viewed product clicked:', productLink.href);
        console.log('Current store:', currentStore, 'Product vendor:', targetVendor);
        
        // Check if we need to switch stores
        if (currentStore !== targetVendor && !currentStore.includes('shop all')) {
          e.preventDefault(); // Prevent default navigation
          
          // Switch store and then navigate
          switchStoreAndNavigate(productLink.href, targetVendor);
        }
        // If stores match or "shop all" is selected, proceed normally
      });
      
      // Add visual indicator for different vendors
      const currentStore = localStorage.getItem('store-selected') || '';
      if (productVendor && currentStore && !currentStore.includes('shop all')) {
        if (productVendor.toLowerCase() !== currentStore.toLowerCase()) {
          item.classList.add('different-vendor');
          // Add a small indicator
          if (!item.querySelector('.vendor-indicator')) {
            const indicator = document.createElement('div');
            indicator.className = 'vendor-indicator';
            indicator.textContent = productVendor;
            indicator.style.cssText = `
              position: absolute;
              top: 5px;
              right: 5px;
              background: rgba(0,0,0,0.7);
              color: white;
              padding: 2px 6px;
              font-size: 10px;
              border-radius: 3px;
              z-index: 1;
            `;
            item.style.position = 'relative';
            item.appendChild(indicator);
          }
        } else {
          item.classList.remove('different-vendor');
          const indicator = item.querySelector('.vendor-indicator');
          if (indicator) {
            indicator.remove();
          }
        }
      }
    });
  }
  
  function filterRecentlyViewedProducts() {
    const selectedStore = localStorage.getItem("store-selected") || "";
    
    if (!recentlyViewedContainer) return;
    
    // Update section title
    if (titleElement) {
      let titleText = "{{ 'products.general.recent_products' | t }}";
      if (selectedStore && !selectedStore.toLowerCase().includes("shop all")) {
        const capitalizedStore = selectedStore.charAt(0).toUpperCase() + selectedStore.slice(1);
        titleText = `Recently Viewed ${capitalizedStore} Products`;
      }
      titleElement.textContent = titleText;
    }
    
    // Find all product items
    const productItems = recentlyViewedContainer.querySelectorAll(
      '.grid-product, .product-item, .grid__item, [data-product-id], [class*="product"]'
    );
    
    let visibleCount = 0;
    
    productItems.forEach((item) => {
      let productVendor = '';
      
      // Try to get vendor from various sources
      if (item.dataset.vendor) {
        productVendor = item.dataset.vendor.toLowerCase();
      } else {
        // Look for vendor in product text/elements
        const vendorElement = item.querySelector('.grid-product__vendor, [class*="vendor"]');
        if (vendorElement) {
          productVendor = vendorElement.textContent.trim().toLowerCase();
          // Store for future use
          item.dataset.vendor = productVendor;
        } else {
          // Check product title/text for vendor names
          const itemText = item.textContent.toLowerCase();
          if (itemText.includes('oxygen')) {
            productVendor = 'oxygen';
            item.dataset.vendor = 'oxygen';
          } else if (itemText.includes('quorum')) {
            productVendor = 'quorum';
            item.dataset.vendor = 'quorum';
          }
        }
      }
      
      // Determine if product should be shown
      const shouldShow = !selectedStore || 
                        selectedStore === '' ||
                        selectedStore.toLowerCase().includes("shop all") || 
                        productVendor === selectedStore.toLowerCase();
      
      if (shouldShow) {
        item.style.display = '';
        visibleCount++;
      } else {
        item.style.display = 'none';
      }
    });
    
    // Add click handlers after filtering
    setTimeout(addProductClickHandlers, 100);
    
    // Only hide section if we have a specific store selected and no matching products
    const sectionElement = recentlyViewedSection.querySelector('.index-section');
    if (sectionElement) {
      if (visibleCount === 0 && selectedStore && !selectedStore.toLowerCase().includes("shop all")) {
        sectionElement.style.display = 'none';
      } else {
        sectionElement.style.display = '';
      }
    }
  }
  
  // Enhanced recently viewed function to include vendor data
  function setupRecentlyViewedFiltering() {
    if (window.recentlyViewed && originalGetRecentProducts) {
      window.recentlyViewed.getRecentProducts = function() {
        const allRecentProducts = originalGetRecentProducts();
        const selectedStore = localStorage.getItem("store-selected") || "";
        
        // Add vendor data to products if missing and filter
        const enhancedProducts = allRecentProducts.map(product => {
          if (!product.vendor && product.title) {
            // Try to determine vendor from product title or other data
            const titleLower = product.title.toLowerCase();
            if (titleLower.includes('oxygen')) {
              product.vendor = 'Oxygen';
            } else if (titleLower.includes('quorum')) {
              product.vendor = 'Quorum';
            }
          }
          return product;
        });
        
        // Filter by selected store if not "shop all"
        if (!selectedStore || selectedStore.toLowerCase().includes("shop all")) {
          return enhancedProducts;
        }
        
        return enhancedProducts.filter(product => {
          return product.vendor && product.vendor.toLowerCase() === selectedStore.toLowerCase();
        });
      };
    }
  }
  
  // Listen for store changes
  document.addEventListener('storeChanged', function(e) {
    console.log('Store changed, re-filtering recently viewed...');
    setTimeout(function() {
      setupRecentlyViewedFiltering();
      filterRecentlyViewedProducts();
      
      // Trigger recently viewed to refresh if possible
      if (window.recentlyViewed && window.recentlyViewed.showRecentlyViewed) {
        window.recentlyViewed.showRecentlyViewed();
      }
    }, 100);
  });
  
  // Initial setup
  setTimeout(function() {
    setupRecentlyViewedFiltering();
    filterRecentlyViewedProducts();
  }, 500);
  
  // Monitor for changes to recently viewed container
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList' && mutation.target === recentlyViewedContainer) {
        console.log('Recently viewed products updated, re-filtering...');
        setTimeout(function() {
          filterRecentlyViewedProducts();
        }, 100);
      }
    });
  });
  
  if (recentlyViewedContainer) {
    observer.observe(recentlyViewedContainer, { childList: true, subtree: true });
  }
});
</script>

{% schema %}
{
  "name": "t:sections.recently-viewed.name",
  "settings": [
    {
      "type": "paragraph",
      "content": "t:sections.recently-viewed.settings.content"
    },
    {
      "type": "range",
      "id": "recent_count",
      "label": "t:sections.recently-viewed.settings.recent_count.label",
      "default": 5,
      "min": 2,
      "max": 10,
      "step": 1
    }
  ],
  "disabled_on": {
    "groups": ["footer", "header", "custom.popups"]
  }
}
{% endschema %}